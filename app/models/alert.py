# app/models/alert.py - FIXED VERSION (Database Schema Compliant)
"""
Alert Model - Alerts table mapping
Represents security alerts generated by detection engine (FIXED column names)
"""

from datetime import datetime, timedelta
from typing import Optional, Dict, List
from sqlalchemy import Column, String, DateTime, Integer, BigInteger, Text, Numeric
from sqlalchemy.dialects.mssql import UNIQUEIDENTIFIER
from sqlalchemy.sql import func
import logging

from ..database import Base

logger = logging.getLogger(__name__)

class Alert(Base):
    """Alert model representing security alerts - FIXED for database compatibility"""
    
    __tablename__ = 'Alerts'
    
    # Primary Key - FIXED: matches BIGINT IDENTITY(1,1) PRIMARY KEY exactly
    AlertID = Column(BigInteger, primary_key=True)
    
    # Foreign Keys - FIXED: matches database schema exactly
    AgentID = Column(UNIQUEIDENTIFIER, nullable=False)
    EventID = Column(BigInteger)
    RuleID = Column(Integer)
    ThreatID = Column(Integer)
    
    # Alert Information - FIXED: matches database schema column names EXACTLY
    AlertType = Column(String(100), nullable=False)
    Title = Column(String(255), nullable=False)
    Description = Column(Text)
    Severity = Column(String(20), nullable=False)
    Priority = Column(String(20), nullable=False, default='Medium')
    # FIXED: DECIMAL(3,2) precision matching DB schema exactly
    Confidence = Column(Numeric(3, 2), nullable=False, default=0.5)
    
    # Detection Information - FIXED: matches database schema exactly
    DetectionMethod = Column(String(50), nullable=False)
    RiskScore = Column(Integer, nullable=False, default=0)
    
    # MITRE ATT&CK Context - FIXED: matches database schema exactly
    MitreTactic = Column(String(100))
    MitreTechnique = Column(String(100))
    
    # Status & Workflow - FIXED: matches simplified schema (no user tables)
    Status = Column(String(20), nullable=False, default='Open')
    AssignedTo = Column(String(100))  # Simple string instead of UserID
    
    # Response Actions - matches database schema
    ResponseAction = Column(Text)
    
    # Timing Information - CRITICAL FIX: matches database schema column names EXACTLY
    FirstDetected = Column(DateTime, nullable=False, default=func.getdate())
    LastDetected = Column(DateTime, nullable=False, default=func.getdate())
    ResolvedAt = Column(DateTime)
    ResolvedBy = Column(String(100))  # Simple string instead of UserID
    
    # Event Count (for aggregated alerts) - FIXED: matches database schema
    EventCount = Column(Integer, nullable=False, default=1)
    
    # Metadata - FIXED: matches DEFAULT GETDATE()
    CreatedAt = Column(DateTime, nullable=False, default=func.getdate())
    UpdatedAt = Column(DateTime, nullable=False, default=func.getdate())
    
    def __repr__(self):
        return f"<Alert(id={self.AlertID}, type='{self.AlertType}', severity='{self.Severity}', status='{self.Status}')>"
    
    def to_dict(self) -> Dict:
        """Convert alert to dictionary for JSON serialization - FIXED"""
        try:
            return {
                'alert_id': self.AlertID,
                'agent_id': str(self.AgentID),
                'event_id': self.EventID,
                'rule_id': self.RuleID,
                'threat_id': self.ThreatID,
                'alert_type': self.AlertType,
                'title': self.Title,
                'description': self.Description,
                'severity': self.Severity,
                'priority': self.Priority,
                # FIXED: Proper DECIMAL handling
                'confidence': float(self.Confidence) if self.Confidence is not None else 0.5,
                'detection_method': self.DetectionMethod,
                'risk_score': self.RiskScore,
                'mitre_tactic': self.MitreTactic,
                'mitre_technique': self.MitreTechnique,
                'status': self.Status,
                'assigned_to': self.AssignedTo,
                # FIXED: Use correct column names that match database
                'first_detected': self.FirstDetected.isoformat() if self.FirstDetected else None,
                'last_detected': self.LastDetected.isoformat() if self.LastDetected else None,
                'resolved_at': self.ResolvedAt.isoformat() if self.ResolvedAt else None,
                'resolved_by': self.ResolvedBy,
                'event_count': self.EventCount,
                'response_action': self.ResponseAction,
                'created_at': self.CreatedAt.isoformat() if self.CreatedAt else None,
                'updated_at': self.UpdatedAt.isoformat() if self.UpdatedAt else None,
                'age_minutes': self.get_age_minutes(),
                'is_critical': self.is_critical(),
                'is_open': self.is_open()
            }
        except Exception as e:
            logger.error(f"Error converting alert to dict: {e}")
            return {'error': 'Conversion failed'}
    
    def to_summary(self) -> Dict:
        """Convert to summary format for lists - FIXED"""
        try:
            return {
                'alert_id': self.AlertID,
                'agent_id': str(self.AgentID),
                'alert_type': self.AlertType,
                'title': self.Title,
                'severity': self.Severity,
                'status': self.Status,
                'detection_method': self.DetectionMethod,
                'first_detected': self.FirstDetected.isoformat() if self.FirstDetected else None,
                'event_count': self.EventCount,
                'age_minutes': self.get_age_minutes()
            }
        except Exception as e:
            logger.error(f"Error creating alert summary: {e}")
            return {'error': 'Summary creation failed'}
    
    def get_age_minutes(self) -> int:
        """Get alert age in minutes"""
        if not self.FirstDetected:
            return 0
        try:
            now = datetime.now()
            time_diff = now - self.FirstDetected
            return int(time_diff.total_seconds() / 60)
        except Exception:
            return 0
    
    def is_critical(self) -> bool:
        """Check if alert is critical"""
        try:
            return (self.Severity in ['High', 'Critical'] or 
                   (self.RiskScore is not None and self.RiskScore >= 80))
        except Exception:
            return False
    
    def is_open(self) -> bool:
        """Check if alert is open"""
        return self.Status in ['Open', 'Investigating']
    
    def update_status(self, status: str, assigned_to: Optional[str] = None, resolved_by: Optional[str] = None):
        """Update alert status - FIXED with validation"""
        valid_statuses = ['Open', 'Investigating', 'Resolved', 'False Positive', 'Suppressed']
        if status not in valid_statuses:
            raise ValueError(f"Invalid status: {status}. Must be one of {valid_statuses}")
        
        try:
            self.Status = status
            self.LastDetected = datetime.now()  # Update last detected time
            
            if assigned_to:
                self.AssignedTo = assigned_to[:100]  # Truncate to max length
            
            if status == 'Resolved':
                self.ResolvedAt = datetime.now()
                if resolved_by:
                    self.ResolvedBy = resolved_by[:100]  # Truncate to max length
            
            # Don't update UpdatedAt here - let trigger handle it
            
        except Exception as e:
            logger.error(f"Error updating alert status: {e}")
            raise
    
    def increment_event_count(self):
        """Increment event count for alert correlation"""
        try:
            self.EventCount = (self.EventCount or 0) + 1
            self.LastDetected = datetime.now()
        except Exception as e:
            logger.error(f"Error incrementing event count: {e}")
    
    def add_response_action(self, action: str):
        """Add response action to alert"""
        try:
            if self.ResponseAction:
                self.ResponseAction += f"\n{datetime.now().isoformat()}: {action}"
            else:
                self.ResponseAction = f"{datetime.now().isoformat()}: {action}"
        except Exception as e:
            logger.error(f"Error adding response action: {e}")
    
    def get_duration_minutes(self) -> Optional[int]:
        """Get duration from first to last detected in minutes"""
        if not self.FirstDetected or not self.LastDetected:
            return None
        try:
            time_diff = self.LastDetected - self.FirstDetected
            return int(time_diff.total_seconds() / 60)
        except Exception:
            return None
    
    def get_time_to_resolution_minutes(self) -> Optional[int]:
        """Get time from detection to resolution in minutes"""
        if not self.FirstDetected or not self.ResolvedAt:
            return None
        try:
            time_diff = self.ResolvedAt - self.FirstDetected
            return int(time_diff.total_seconds() / 60)
        except Exception:
            return None
    
    @classmethod
    def create_alert(cls, agent_id: str, alert_type: str, title: str, severity: str, 
                    detection_method: str, **kwargs):
        """Create new alert instance - FIXED with validation"""
        try:
            # Validate required fields
            if not all([agent_id, alert_type, title, severity, detection_method]):
                raise ValueError("agent_id, alert_type, title, severity, and detection_method are required")
            
            # Validate severity
            valid_severities = ['Low', 'Medium', 'High', 'Critical']
            if severity not in valid_severities:
                raise ValueError(f"Invalid severity. Must be one of {valid_severities}")
            
            # Validate alert_type length
            if len(alert_type) > 100:
                logger.warning(f"Alert type truncated from {len(alert_type)} to 100 characters")
                alert_type = alert_type[:100]
            
            # Validate title length
            if len(title) > 255:
                logger.warning(f"Alert title truncated from {len(title)} to 255 characters")
                title = title[:255]
            
            # Validate detection_method length
            if len(detection_method) > 50:
                logger.warning(f"Detection method truncated from {len(detection_method)} to 50 characters")
                detection_method = detection_method[:50]
            
            # Create alert with validated data
            alert = cls(
                AgentID=agent_id,
                AlertType=alert_type,
                Title=title,
                Severity=severity,
                DetectionMethod=detection_method,
                **{k: v for k, v in kwargs.items() if hasattr(cls, k) and v is not None}  # Only valid attributes and non-None values
            )
            
            # Set defaults for computed fields
            if not hasattr(alert, 'Priority') or not alert.Priority:
                alert.Priority = cls._map_severity_to_priority(severity)
            
            if not hasattr(alert, 'RiskScore') or alert.RiskScore is None:
                alert.RiskScore = cls._map_severity_to_risk_score(severity)
            
            return alert
            
        except Exception as e:
            logger.error(f"Error creating alert: {e}")
            raise ValueError(f"Failed to create alert: {e}")
    
    @classmethod
    def _map_severity_to_priority(cls, severity: str) -> str:
        """Map severity to priority level"""
        mapping = {
            'Low': 'Low',
            'Medium': 'Medium', 
            'High': 'High',
            'Critical': 'Critical'
        }
        return mapping.get(severity, 'Medium')
    
    @classmethod
    def _map_severity_to_risk_score(cls, severity: str) -> int:
        """Map severity to risk score"""
        mapping = {
            'Low': 25,
            'Medium': 50,
            'High': 75,
            'Critical': 90
        }
        return mapping.get(severity, 50)
    
    @classmethod
    def get_open_alerts(cls, session):
        """Get all open alerts - FIXED"""
        try:
            return session.query(cls).filter(
                cls.Status.in_(['Open', 'Investigating'])
            ).order_by(cls.Severity.desc(), cls.FirstDetected.desc()).all()
        except Exception as e:
            logger.error(f"Error getting open alerts: {e}")
            return []
    
    @classmethod
    def get_critical_alerts(cls, session):
        """Get critical alerts - FIXED"""
        try:
            return session.query(cls).filter(
                cls.Status.in_(['Open', 'Investigating']),
                cls.Severity.in_(['High', 'Critical'])
            ).order_by(cls.FirstDetected.desc()).all()
        except Exception as e:
            logger.error(f"Error getting critical alerts: {e}")
            return []
    
    @classmethod
    def get_alerts_summary(cls, session, hours: int = 24) -> Dict:
        """Get alert summary statistics - FIXED"""
        try:
            from sqlalchemy import func as sql_func
            
            cutoff_time = datetime.now() - timedelta(hours=hours)
            
            # Total alerts in time range
            total = session.query(sql_func.count(cls.AlertID)).filter(
                cls.FirstDetected >= cutoff_time
            ).scalar() or 0
            
            # Open alerts (current)
            open_alerts = session.query(sql_func.count(cls.AlertID)).filter(
                cls.Status.in_(['Open', 'Investigating'])
            ).scalar() or 0
            
            # Critical alerts (current)
            critical_alerts = session.query(sql_func.count(cls.AlertID)).filter(
                cls.Status.in_(['Open', 'Investigating']),
                cls.Severity.in_(['High', 'Critical'])
            ).scalar() or 0
            
            # Resolved alerts in time range
            resolved_alerts = session.query(sql_func.count(cls.AlertID)).filter(
                cls.FirstDetected >= cutoff_time,
                cls.Status == 'Resolved'
            ).scalar() or 0
            
            return {
                'total_alerts': total,
                'open_alerts': open_alerts,
                'critical_alerts': critical_alerts,
                'resolved_alerts': resolved_alerts,
                'time_range_hours': hours
            }
            
        except Exception as e:
            logger.error(f"Error getting alerts summary: {e}")
            return {
                'total_alerts': 0,
                'open_alerts': 0,
                'critical_alerts': 0,
                'resolved_alerts': 0,
                'time_range_hours': hours
            }
    
    @classmethod
    def get_alerts_by_agent(cls, session, agent_id: str, hours: int = 24):
        """Get alerts for specific agent - FIXED"""
        try:
            cutoff_time = datetime.now() - timedelta(hours=hours)
            return session.query(cls).filter(
                cls.AgentID == agent_id,
                cls.FirstDetected >= cutoff_time
            ).order_by(cls.FirstDetected.desc()).all()
        except Exception as e:
            logger.error(f"Error getting alerts for agent: {e}")
            return []
    
    @classmethod
    def get_alerts_by_rule(cls, session, rule_id: int, hours: int = 24):
        """Get alerts generated by specific rule - FIXED"""
        try:
            cutoff_time = datetime.now() - timedelta(hours=hours)
            return session.query(cls).filter(
                cls.RuleID == rule_id,
                cls.FirstDetected >= cutoff_time
            ).order_by(cls.FirstDetected.desc()).all()
        except Exception as e:
            logger.error(f"Error getting alerts for rule: {e}")
            return []
    
    @classmethod
    def get_alerts_by_threat(cls, session, threat_id: int, hours: int = 24):
        """Get alerts related to specific threat - FIXED"""
        try:
            cutoff_time = datetime.now() - timedelta(hours=hours)
            return session.query(cls).filter(
                cls.ThreatID == threat_id,
                cls.FirstDetected >= cutoff_time
            ).order_by(cls.FirstDetected.desc()).all()
        except Exception as e:
            logger.error(f"Error getting alerts for threat: {e}")
            return []
    
    @classmethod
    def cleanup_old_alerts(cls, session, retention_days: int = 90) -> int:
        """Clean up old resolved alerts - NEW"""
        try:
            cutoff_date = datetime.now() - timedelta(days=retention_days)
            
            # Delete old resolved alerts
            deleted_count = session.query(cls).filter(
                cls.Status.in_(['Resolved', 'False Positive']),
                cls.ResolvedAt < cutoff_date
            ).delete()
            
            session.commit()
            
            if deleted_count > 0:
                logger.info(f"Cleaned up {deleted_count} old alerts")
            
            return deleted_count
            
        except Exception as e:
            session.rollback()
            logger.error(f"Alert cleanup failed: {e}")
            return 0
    
    @classmethod
    def get_detection_effectiveness(cls, session, hours: int = 24) -> Dict:
        """Get detection effectiveness metrics - NEW"""
        try:
            cutoff_time = datetime.now() - timedelta(hours=hours)
            
            # Alerts by detection method
            detection_methods = session.query(
                cls.DetectionMethod,
                func.count(cls.AlertID).label('count'),
                func.avg(cls.RiskScore).label('avg_risk_score')
            ).filter(
                cls.FirstDetected >= cutoff_time
            ).group_by(cls.DetectionMethod).all()
            
            # Resolution rate
            total_alerts = session.query(cls).filter(cls.FirstDetected >= cutoff_time).count()
            resolved_alerts = session.query(cls).filter(
                cls.FirstDetected >= cutoff_time,
                cls.Status == 'Resolved'
            ).count()
            
            resolution_rate = (resolved_alerts / total_alerts * 100) if total_alerts > 0 else 0
            
            return {
                'detection_methods': [
                    {
                        'method': method,
                        'alert_count': count,
                        'avg_risk_score': float(avg_risk_score) if avg_risk_score else 0
                    }
                    for method, count, avg_risk_score in detection_methods
                ],
                'resolution_rate': round(resolution_rate, 2),
                'total_alerts': total_alerts,
                'resolved_alerts': resolved_alerts
            }
            
        except Exception as e:
            logger.error(f"Error getting detection effectiveness: {e}")
            return {}