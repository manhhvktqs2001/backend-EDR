# app/models/alert.py - Complete Alert Model (Database Schema Compliant)
"""
Alert Model - Alerts table mapping
Represents security alerts generated by detection engine
"""

from datetime import datetime, timedelta
from typing import Optional, Dict, List
from sqlalchemy import Column, String, DateTime, Integer, BigInteger, Text, Numeric
from sqlalchemy.dialects.mssql import UNIQUEIDENTIFIER
from sqlalchemy.sql import func

from ..database import Base

class Alert(Base):
    """Alert model representing security alerts"""
    
    __tablename__ = 'Alerts'
    
    # Primary Key - matches BIGINT IDENTITY(1,1) PRIMARY KEY exactly
    AlertID = Column(BigInteger, primary_key=True)
    
    # Foreign Keys - matches database schema exactly
    AgentID = Column(UNIQUEIDENTIFIER, nullable=False)
    EventID = Column(BigInteger)
    RuleID = Column(Integer)
    ThreatID = Column(Integer)
    
    # Alert Information - matches database schema column names exactly
    AlertType = Column(String(100), nullable=False)
    Title = Column(String(255), nullable=False)
    Description = Column(Text)
    Severity = Column(String(20), nullable=False)
    Priority = Column(String(20), default='Medium')
    Confidence = Column(Numeric(3, 2), default=0.5)
    
    # Detection Information - matches database schema exactly
    DetectionMethod = Column(String(50), nullable=False)
    RiskScore = Column(Integer, default=0)
    
    # MITRE ATT&CK Context - matches database schema exactly
    MitreTactic = Column(String(100))
    MitreTechnique = Column(String(100))
    
    # Status & Workflow - matches simplified schema (no user tables)
    Status = Column(String(20), default='Open')
    AssignedTo = Column(String(100))  # Simple string instead of UserID
    
    # Response Actions - matches database schema
    ResponseAction = Column(Text)
    
    # Timing Information - matches database schema exactly
    FirstDetected = Column(DateTime, default=func.getdate())
    LastDetected = Column(DateTime, default=func.getdate())
    ResolvedAt = Column(DateTime)
    ResolvedBy = Column(String(100))  # Simple string instead of UserID
    
    # Event Count (for aggregated alerts) - matches database schema
    EventCount = Column(Integer, default=1)
    
    # Metadata - matches DEFAULT GETDATE()
    CreatedAt = Column(DateTime, default=func.getdate())
    UpdatedAt = Column(DateTime, default=func.getdate(), onupdate=func.getdate())
    
    def __repr__(self):
        return f"<Alert(id={self.AlertID}, type='{self.AlertType}', severity='{self.Severity}', status='{self.Status}')>"
    
    def to_dict(self) -> Dict:
        """Convert alert to dictionary for JSON serialization"""
        return {
            'alert_id': self.AlertID,
            'agent_id': str(self.AgentID),
            'event_id': self.EventID,
            'rule_id': self.RuleID,
            'threat_id': self.ThreatID,
            'alert_type': self.AlertType,
            'title': self.Title,
            'description': self.Description,
            'severity': self.Severity,
            'priority': self.Priority,
            'confidence': float(self.Confidence) if self.Confidence else 0.5,
            'detection_method': self.DetectionMethod,
            'risk_score': self.RiskScore,
            'mitre_tactic': self.MitreTactic,
            'mitre_technique': self.MitreTechnique,
            'status': self.Status,
            'assigned_to': self.AssignedTo,
            'first_detected': self.FirstDetected.isoformat() if self.FirstDetected else None,
            'last_detected': self.LastDetected.isoformat() if self.LastDetected else None,
            'resolved_at': self.ResolvedAt.isoformat() if self.ResolvedAt else None,
            'resolved_by': self.ResolvedBy,
            'event_count': self.EventCount,
            'response_action': self.ResponseAction,
            'created_at': self.CreatedAt.isoformat() if self.CreatedAt else None,
            'updated_at': self.UpdatedAt.isoformat() if self.UpdatedAt else None,
            'age_minutes': self.get_age_minutes(),
            'is_critical': self.is_critical(),
            'is_open': self.is_open()
        }
    
    def to_summary(self) -> Dict:
        """Convert to summary format for lists"""
        return {
            'alert_id': self.AlertID,
            'agent_id': str(self.AgentID),
            'alert_type': self.AlertType,
            'title': self.Title,
            'severity': self.Severity,
            'status': self.Status,
            'detection_method': self.DetectionMethod,
            'first_detected': self.FirstDetected.isoformat() if self.FirstDetected else None,
            'event_count': self.EventCount,
            'age_minutes': self.get_age_minutes()
        }
    
    def get_age_minutes(self) -> int:
        """Get alert age in minutes"""
        if not self.FirstDetected:
            return 0
        now = datetime.now()
        time_diff = now - self.FirstDetected
        return int(time_diff.total_seconds() / 60)
    
    def is_critical(self) -> bool:
        """Check if alert is critical"""
        return self.Severity in ['High', 'Critical'] or self.RiskScore >= 80
    
    def is_open(self) -> bool:
        """Check if alert is open"""
        return self.Status in ['Open', 'Investigating']
    
    def update_status(self, status: str, assigned_to: Optional[str] = None, resolved_by: Optional[str] = None):
        """Update alert status"""
        valid_statuses = ['Open', 'Investigating', 'Resolved', 'False Positive', 'Suppressed']
        if status not in valid_statuses:
            raise ValueError(f"Invalid status: {status}. Must be one of {valid_statuses}")
        
        self.Status = status
        self.UpdatedAt = datetime.now()
        
        if assigned_to:
            self.AssignedTo = assigned_to
        
        if status == 'Resolved' and resolved_by:
            self.ResolvedAt = datetime.now()
            self.ResolvedBy = resolved_by
    
    @classmethod
    def create_alert(cls, agent_id: str, alert_type: str, title: str, severity: str, 
                    detection_method: str, **kwargs):
        """Create new alert instance"""
        alert = cls(
            AgentID=agent_id,
            AlertType=alert_type,
            Title=title,
            Severity=severity,
            DetectionMethod=detection_method,
            **kwargs
        )
        return alert
    
    @classmethod
    def get_open_alerts(cls, session):
        """Get all open alerts"""
        return session.query(cls).filter(
            cls.Status.in_(['Open', 'Investigating'])
        ).order_by(cls.Severity.desc(), cls.FirstDetected.desc()).all()
    
    @classmethod
    def get_critical_alerts(cls, session):
        """Get critical alerts"""
        return session.query(cls).filter(
            cls.Status.in_(['Open', 'Investigating']),
            cls.Severity.in_(['High', 'Critical'])
        ).order_by(cls.FirstDetected.desc()).all()
    
    @classmethod
    def get_alerts_summary(cls, session, hours: int = 24) -> Dict:
        """Get alert summary statistics"""
        from sqlalchemy import func as sql_func
        
        cutoff_time = datetime.now() - timedelta(hours=hours)
        
        total = session.query(sql_func.count(cls.AlertID)).filter(
            cls.FirstDetected >= cutoff_time
        ).scalar() or 0
        
        open_alerts = session.query(sql_func.count(cls.AlertID)).filter(
            cls.Status.in_(['Open', 'Investigating'])
        ).scalar() or 0
        
        critical_alerts = session.query(sql_func.count(cls.AlertID)).filter(
            cls.Status.in_(['Open', 'Investigating']),
            cls.Severity.in_(['High', 'Critical'])
        ).scalar() or 0
        
        return {
            'total_alerts': total,
            'open_alerts': open_alerts,
            'critical_alerts': critical_alerts,
            'resolved_alerts': total - open_alerts
        }